/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.launcher2;

import java.util.ArrayList;

import android.animation.Animator;
import android.animation.AnimatorListenerAdapter;
import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.ValueAnimator;
import android.animation.ValueAnimator.AnimatorUpdateListener;
import android.content.Context;
import android.content.res.Resources;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.text.InputType;
import android.text.Selection;
import android.text.Spannable;
import android.util.AttributeSet;
import android.util.Log;
import android.view.ActionMode;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityManager;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.DecelerateInterpolator;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.android.launcher.R;
import com.android.launcher2.FolderInfo.FolderListener;

/**
 * Represents a set of icons chosen by the user or generated by the system.
 */
public class Folder extends LinearLayout implements DragSource,
		View.OnClickListener, View.OnLongClickListener, DropTarget,
		FolderListener, TextView.OnEditorActionListener,
		View.OnFocusChangeListener {

	private static final String TAG = "Launcher.Folder";

	protected DragController mDragController;
	protected Launcher mLauncher;
	protected FolderInfo mInfo;

	static final int STATE_NONE = -1;
	static final int STATE_SMALL = 0;
	static final int STATE_ANIMATING = 1;
	static final int STATE_OPEN = 2;

	private int mExpandDuration;
	// {Modified by lijuan.li at 2012.07.11 for folder with multipage
	// protected CellLayout mContent;
	protected FolderPagedView mContent;
	// }Modified by lijuan.li end
	private final LayoutInflater mInflater;
	private final IconCache mIconCache;
	private int mState = STATE_NONE;
	private static final int PARTIAL_GROW = 1;
	private static final int REORDER_ANIMATION_DURATION = 230;
	private static final int ON_EXIT_CLOSE_DELAY = 800;
	private int mMode = PARTIAL_GROW;
	private boolean mRearrangeOnClose = false;
	private FolderIcon mFolderIcon;
	private int mMaxCountX;
	private int mMaxCountY;
	private int mMaxNumItems;
	private Rect mNewSize = new Rect();
	private Rect mIconRect = new Rect();
	private ArrayList<View> mItemsInReadingOrder = new ArrayList<View>();
	private ArrayList<ShortcutInfo> mItemsAllPageInReadingOrder = new ArrayList<ShortcutInfo>();
	private Drawable mIconDrawable;
	boolean mItemsInvalidated = false;
	private ShortcutInfo mCurrentDragInfo;
	private View mCurrentDragView;
	boolean mSuppressOnAdd = false;
	private int[] mTargetCell = new int[2];
	private int[] mPreviousTargetCell = new int[2];
	private int[] mEmptyCell = new int[2];
	private Alarm mReorderAlarm = new Alarm();
	private Alarm mOnExitAlarm = new Alarm();
	private int mFolderNameHeight;
	private Rect mTempRect = new Rect();
	private boolean mDragInProgress = false;
	private boolean mDeleteFolderOnDropCompleted = false;
	private boolean mSuppressFolderDeletion = false;
	private boolean mItemAddedBackToSelfViaIcon = false;
	FolderEditText mFolderName;
	// {Added by lijuan.li at 2012.07.11 for folder with multipage
	private int mPageCount;
	// }Added by lijuan.li end

	private boolean mIsEditingName = false;
	private InputMethodManager mInputMethodManager;

	private static String sDefaultFolderName;
	private static String sHintText;

	/**
	 * Used to inflate the Workspace from XML.
	 * 
	 * @param context
	 *            The application's context.
	 * @param attrs
	 *            The attribtues set containing the Workspace's customization
	 *            values.
	 */
	public Folder(Context context, AttributeSet attrs) {
		super(context, attrs);
		setAlwaysDrawnWithCacheEnabled(false);
		mInflater = LayoutInflater.from(context);
		mIconCache = ((LauncherApplication) context.getApplicationContext())
				.getIconCache();

		Resources res = getResources();
		mMaxCountX = res.getInteger(R.integer.folder_max_count_x);
		mMaxCountY = res.getInteger(R.integer.folder_max_count_y);
		mMaxNumItems = res.getInteger(R.integer.folder_max_num_items);
		if (mMaxCountX < 0 || mMaxCountY < 0 || mMaxNumItems < 0) {
			mMaxCountX = LauncherModel.getCellCountX();
			mMaxCountY = LauncherModel.getCellCountY();
			mMaxNumItems = mMaxCountX * mMaxCountY;
		}

		mInputMethodManager = (InputMethodManager) mContext
				.getSystemService(Context.INPUT_METHOD_SERVICE);

		mExpandDuration = res.getInteger(R.integer.config_folderAnimDuration);

		if (sDefaultFolderName == null) {
			sDefaultFolderName = res.getString(R.string.folder_name);
		}
		if (sHintText == null) {
			sHintText = res.getString(R.string.folder_hint_text);
		}
		mLauncher = (Launcher) context;
		// We need this view to be focusable in touch mode so that when text
		// editing of the folder
		// name is complete, we have something to focus on, thus hiding the
		// cursor and giving
		// reliable behvior when clicking the text field (since it will always
		// gain focus on click).
		setFocusableInTouchMode(true);
	}

	@Override
	protected void onFinishInflate() {
		super.onFinishInflate();
		// {Modified by lijuan.li at 2012.07.11 for folder with multipage
		// mContent = (CellLayout) findViewById(R.id.folder_content);
		// mContent.setGridSize(0, 0);
		// mContent.getChildrenLayout().setMotionEventSplittingEnabled(false);
		mContent = (FolderPagedView) findViewById(R.id.folder_content);
		// }Modified by lijuan.li end
		mFolderName = (FolderEditText) findViewById(R.id.folder_name);
		mFolderName.setFolder(this);
		mFolderName.setOnFocusChangeListener(this);

		// We find out how tall the text view wants to be (it is set to
		// wrap_content), so that
		// we can allocate the appropriate amount of space for it.
		int measureSpec = MeasureSpec.UNSPECIFIED;
		mFolderName.measure(measureSpec, measureSpec);
		mFolderNameHeight = mFolderName.getMeasuredHeight();

		// We disable action mode for now since it messes up the view on phones
		mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
		mFolderName.setOnEditorActionListener(this);
		mFolderName.setSelectAllOnFocus(true);
		mFolderName.setInputType(mFolderName.getInputType()
				| InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS
				| InputType.TYPE_TEXT_FLAG_CAP_WORDS);
	}

	private ActionMode.Callback mActionModeCallback = new ActionMode.Callback() {
		public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
			return false;
		}

		public boolean onCreateActionMode(ActionMode mode, Menu menu) {
			return false;
		}

		public void onDestroyActionMode(ActionMode mode) {
		}

		public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
			return false;
		}
	};

	public void onClick(View v) {
		Object tag = v.getTag();
		if (tag instanceof ShortcutInfo) {
			// refactor this code from Folder
			ShortcutInfo item = (ShortcutInfo) tag;
			int[] pos = new int[2];
			v.getLocationOnScreen(pos);
			item.intent.setSourceBounds(new Rect(pos[0], pos[1], pos[0]
					+ v.getWidth(), pos[1] + v.getHeight()));
			mLauncher.startActivitySafely(item.intent, item);
		}
	}

	public boolean onLongClick(View v) {
		Object tag = v.getTag();
		if (tag instanceof ShortcutInfo) {
			ShortcutInfo item = (ShortcutInfo) tag;
			if (!v.isInTouchMode()) {
				return false;
			}

			mLauncher.dismissFolderCling(null);

			mLauncher.getWorkspace().onDragStartedWithItem(v);
			mLauncher.getWorkspace().beginDragShared(v, this);
			mIconDrawable = ((TextView) v).getCompoundDrawables()[1];

			mCurrentDragInfo = item;
			mEmptyCell[0] = item.cellX;
			mEmptyCell[1] = item.cellY;
			mCurrentDragView = v;

			// {Modified by lijuan.li at 2012.07.11 for folder with multipage
			// mContent.removeView(mCurrentDragView);
			CellLayout cl = (CellLayout) (mContent.getChildAt(mContent
					.getCurrentScreen()));
			cl.removeView(mCurrentDragView);
			// }Modified by lijuan.li end
			mInfo.remove(mCurrentDragInfo);
			mDragInProgress = true;
			mItemAddedBackToSelfViaIcon = false;
		}
		return true;
	}

	public boolean isEditingName() {
		return mIsEditingName;
	}

	public void startEditingFolderName() {
		mFolderName.setHint("");
		mIsEditingName = true;
	}

	public void dismissEditingName() {
		mInputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
		doneEditingFolderName(true);
	}

	public void doneEditingFolderName(boolean commit) {
		mFolderName.setHint(sHintText);
		// Convert to a string here to ensure that no other state associated
		// with the text field
		// gets saved.
		String newTitle = mFolderName.getText().toString();
		mInfo.setTitle(newTitle);
		LauncherModel.updateItemInDatabase(mLauncher, mInfo);

		if (commit) {
			sendCustomAccessibilityEvent(
					AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
					String.format(mContext.getString(R.string.folder_renamed),
							newTitle));
		}
		// In order to clear the focus from the text field, we set the focus on
		// ourself. This
		// ensures that every time the field is clicked, focus is gained, giving
		// reliable behavior.
		requestFocus();

		Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
		mIsEditingName = false;
	}

	public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
		if (actionId == EditorInfo.IME_ACTION_DONE) {
			dismissEditingName();
			return true;
		}
		return false;
	}

	public View getEditTextRegion() {
		return mFolderName;
	}

	public Drawable getDragDrawable() {
		return mIconDrawable;
	}

	/**
	 * We need to handle touch events to prevent them from falling through to
	 * the workspace below.
	 */
	@Override
	public boolean onTouchEvent(MotionEvent ev) {
		return true;
	}

	public void setDragController(DragController dragController) {
		mDragController = dragController;
	}

	void setFolderIcon(FolderIcon icon) {
		mFolderIcon = icon;
	}

	@Override
	public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
		// When the folder gets focus, we don't want to announce the list of
		// items.
		return true;
	}

	/**
	 * @return the FolderInfo object associated with this folder
	 */
	FolderInfo getInfo() {
		return mInfo;
	}

	void bind(FolderInfo info) {
		mInfo = info;
		
		ArrayList<ShortcutInfo> children = info.contents;
		ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
		/*
		 * setupContentForNumItems(children.size()); int count = 0; for (int i =
		 * 0; i < children.size(); i++) { ShortcutInfo child = (ShortcutInfo)
		 * children.get(i); if (!createAndAddShortcut(child)) {
		 * overflow.add(child); } else { count++; } }
		 * 
		 * // We rearrange the items in case there are any empty gaps
		 * setupContentForNumItems(count);
		 */

		mPageCount = (children.size() - 1) / mMaxNumItems + 1;

		if (mPageCount > 1) {
			for (int pagecount = 0; pagecount < mPageCount; pagecount++) {
				CellLayout cl = (CellLayout) LayoutInflater.from(getContext())
						.inflate(R.layout.folder_layout, this, false);
				cl.setGridSize(mMaxCountX, mMaxCountY);
				mContent.addView(cl);
				setupContentForNumItems(mMaxNumItems, pagecount);
			}
		} else {
			CellLayout cl = (CellLayout) LayoutInflater.from(getContext())
					.inflate(R.layout.folder_layout, this, false);
			cl.setGridSize(0, 0);
			mContent.addView(cl);
			setupContentForNumItems(children.size(), 0);
		}
		
		int childindex = 0;
		for (; childindex < children.size(); childindex++) {
			ShortcutInfo child = (ShortcutInfo) children.get(childindex);
			if (!createAndAddShortcut(child, child.screen)) {
				overflow.add(child);
			}
		}
		// }Modified by lijuan.li end

		// If our folder has too many items we prune them from the list. This is
		// an issue
		// when upgrading from the old Folders implementation which could
		// contain an unlimited
		// number of items.
		for (ShortcutInfo item : overflow) {
			mInfo.remove(item);
			LauncherModel.deleteItemFromDatabase(mLauncher, item);
		}

		mItemsInvalidated = true;
		updateTextViewFocus();
		mInfo.addListener(this);

		if (!sDefaultFolderName.contentEquals(mInfo.title)) {
			mFolderName.setText(mInfo.title);
		} else {
			mFolderName.setText("");
		}
	}

	/**
	 * Creates a new UserFolder, inflated from R.layout.user_folder.
	 * 
	 * @param context
	 *            The application's context.
	 * 
	 * @return A new UserFolder.
	 */
	static Folder fromXml(Context context) {
		return (Folder) LayoutInflater.from(context).inflate(
				R.layout.user_folder, null);
	}

	/**
	 * This method is intended to make the UserFolder to be visually identical
	 * in size and position to its associated FolderIcon. This allows for a
	 * seamless transition into the expanded state.
	 */
	private void positionAndSizeAsIcon() {
		if (!(getParent() instanceof DragLayer))
			return;

		DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

		if (mMode == PARTIAL_GROW) {
			setScaleX(0.8f);
			setScaleY(0.8f);
			setAlpha(0f);
		} else {
			mLauncher.getDragLayer().getDescendantRectRelativeToSelf(
					mFolderIcon, mIconRect);
			lp.width = mIconRect.width();
			lp.height = mIconRect.height();
			lp.x = mIconRect.left;
			lp.y = mIconRect.top;
			mContent.setAlpha(0);
		}
		mState = STATE_SMALL;
	}

	public void animateOpen() {
		positionAndSizeAsIcon();

		if (!(getParent() instanceof DragLayer))
			return;

		ObjectAnimator oa;
		DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

		centerAboutIcon();
		if (mMode == PARTIAL_GROW) {
			PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha",
					1);
			PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(
					"scaleX", 1.0f);
			PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(
					"scaleY", 1.0f);
			oa = ObjectAnimator.ofPropertyValuesHolder(this, alpha, scaleX,
					scaleY);
		} else {
			PropertyValuesHolder width = PropertyValuesHolder.ofInt("width",
					mNewSize.width());
			PropertyValuesHolder height = PropertyValuesHolder.ofInt("height",
					mNewSize.height());
			PropertyValuesHolder x = PropertyValuesHolder.ofInt("x",
					mNewSize.left);
			PropertyValuesHolder y = PropertyValuesHolder.ofInt("y",
					mNewSize.top);
			oa = ObjectAnimator.ofPropertyValuesHolder(lp, width, height, x, y);
			oa.addUpdateListener(new AnimatorUpdateListener() {
				public void onAnimationUpdate(ValueAnimator animation) {
					requestLayout();
				}
			});

			PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha",
					1.0f);
			ObjectAnimator alphaOa = ObjectAnimator.ofPropertyValuesHolder(
					mContent, alpha);
			alphaOa.setDuration(mExpandDuration);
			alphaOa.setInterpolator(new AccelerateInterpolator(2.0f));
			alphaOa.start();
		}

		oa.addListener(new AnimatorListenerAdapter() {
			@Override
			public void onAnimationStart(Animator animation) {
				// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
				/*
				 * sendCustomAccessibilityEvent(AccessibilityEvent.
				 * TYPE_WINDOW_STATE_CHANGED,
				 * String.format(mContext.getString(R.string.folder_opened),
				 * mContent.getCountX(), mContent.getCountY())); mState =
				 * STATE_ANIMATING;
				 */
				CellLayout cl = (CellLayout) (mContent.getChildAt(mContent
						.getCurrentScreen()));
				sendCustomAccessibilityEvent(
						AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
						String.format(
								mContext.getString(R.string.folder_opened),
								cl.getCountX(), cl.getCountY()));
				mState = STATE_ANIMATING;
				// }Modified by lijuan.li end
			}

			@Override
			public void onAnimationEnd(Animator animation) {
				mState = STATE_OPEN;

				Cling cling = mLauncher.showFirstRunFoldersCling();
				if (cling != null) {
					cling.bringToFront();
				}
				setFocusOnFirstChild();
				// {Added by lijuan.li 2012.07.30 begin for folder with multipage
				mContent.invalidate();
				// }Added by lijuan.li
			}
		});
		oa.setDuration(mExpandDuration);
		oa.start();
	}

	private void sendCustomAccessibilityEvent(int type, String text) {
		if (AccessibilityManager.getInstance(mContext).isEnabled()) {
			AccessibilityEvent event = AccessibilityEvent.obtain(type);
			onInitializeAccessibilityEvent(event);
			event.getText().add(text);
			AccessibilityManager.getInstance(mContext).sendAccessibilityEvent(
					event);
		}
	}

	private void setFocusOnFirstChild() {
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
		// View firstChild = mContent.getChildAt(0, 0);
		CellLayout cl = (CellLayout) (mContent.getChildAt(0));
		View firstChild = cl.getChildAt(0, 0);
		// }Modified by lijuan.li end
		if (firstChild != null) {
			firstChild.requestFocus();
		}
	}

	public void animateClosed() {
		if (!(getParent() instanceof DragLayer))
			return;

		ObjectAnimator oa;
		if (mMode == PARTIAL_GROW) {
			PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha",
					0);
			PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat(
					"scaleX", 0.9f);
			PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat(
					"scaleY", 0.9f);
			oa = ObjectAnimator.ofPropertyValuesHolder(this, alpha, scaleX,
					scaleY);
		} else {
			DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();

			PropertyValuesHolder width = PropertyValuesHolder.ofInt("width",
					mIconRect.width());
			PropertyValuesHolder height = PropertyValuesHolder.ofInt("height",
					mIconRect.height());
			PropertyValuesHolder x = PropertyValuesHolder.ofInt("x",
					mIconRect.left);
			PropertyValuesHolder y = PropertyValuesHolder.ofInt("y",
					mIconRect.top);
			oa = ObjectAnimator.ofPropertyValuesHolder(lp, width, height, x, y);
			oa.addUpdateListener(new AnimatorUpdateListener() {
				public void onAnimationUpdate(ValueAnimator animation) {
					requestLayout();
				}
			});

			PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha",
					0f);
			ObjectAnimator alphaOa = ObjectAnimator.ofPropertyValuesHolder(
					mContent, alpha);
			alphaOa.setDuration(mExpandDuration);
			alphaOa.setInterpolator(new DecelerateInterpolator(2.0f));
			alphaOa.start();
		}

		oa.addListener(new AnimatorListenerAdapter() {
			@Override
			public void onAnimationEnd(Animator animation) {
				onCloseComplete();
				mState = STATE_SMALL;
			}

			@Override
			public void onAnimationStart(Animator animation) {
				sendCustomAccessibilityEvent(
						AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED,
						mContext.getString(R.string.folder_closed));
				mState = STATE_ANIMATING;
			}
		});
		oa.setDuration(mExpandDuration);
		oa.start();
	}

	void notifyDataSetChanged() {
		// recreate all the children if the data set changes under us. We may
		// want to do this more
		// intelligently (ie just removing the views that should no longer
		// exist)
		mContent.removeAllViewsInLayout();
		bind(mInfo);
	}

	public boolean acceptDrop(DragObject d) {
		final ItemInfo item = (ItemInfo) d.dragInfo;
		final int itemType = item.itemType;
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
		/*
		 * return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION
		 * || itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) &&
		 * !isFull());
		 */
		return ((itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION || itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT));
		// }Modified by lijuan.li end
	}
	
    protected boolean findAndSetEmptyCells(ShortcutInfo item) {
		// {Deleted by lijuan.li at 2012.07.30 for folder with multipage
		// int[] emptyCell = new int[2];
		// if (mContent.findCellForSpan(emptyCell, item.spanX, item.spanY)) {
		// item.cellX = emptyCell[0];
		// item.cellY = emptyCell[1];
		// return true;
		// } else {
		return false;
		// }
		// }Deleted by lijuan.li end
    }
    
    protected boolean createAndAddShortcut(ShortcutInfo item) {
        final TextView textView =
            (TextView) mInflater.inflate(R.layout.application, this, false);
        textView.setCompoundDrawablesWithIntrinsicBounds(null,
                new FastBitmapDrawable(item.getIcon(mIconCache)), null, null);
        textView.setText(item.title);
        textView.setTag(item);

        textView.setOnClickListener(this);
        textView.setOnLongClickListener(this);

        // We need to check here to verify that the given item's location isn't already occupied
        // by another item. If it is, we need to find the next available slot and assign
        // it that position. This is an issue when upgrading from the old Folders implementation
        // which could contain an unlimited number of items.
        
		// {Deleted by lijuan.li at 2012.07.30 for folder with multipage
		// if (mContent.getChildAt(item.cellX, item.cellY) != null || item.cellX
		// < 0 || item.cellY < 0
		// || item.cellX >= mContent.getCountX() || item.cellY >=
		// mContent.getCountY()) {
		// if (!findAndSetEmptyCells(item)) {
		// return false;
		// }
		// }
		// }Deleted by lijuan.li end

		CellLayout.LayoutParams lp = new CellLayout.LayoutParams(item.cellX,
				item.cellY, item.spanX, item.spanY);
		boolean insert = false;
		textView.setOnKeyListener(new FolderKeyEventListener());
		// {Deleted by lijuan.li at 2012.07.30 for folder with multipage
		// mContent.addViewToCellLayout(textView, insert ? 0 : -1, (int)item.id,
		// lp, true);
		// }Deleted by lijuan.li end
        return true;
    }

	// }Added by lijuan.li 2012.07.11 begin for folder with multipage
	protected boolean findAndSetEmptyCells(ShortcutInfo item, int atChild) {
		CellLayout cl = (CellLayout) (mContent.getChildAt(atChild));
		
		int[] emptyCell = new int[2];
		if (cl.findCellForSpan(emptyCell, item.spanX, item.spanY)) {
			item.cellX = emptyCell[0];
			item.cellY = emptyCell[1];
			return true;
		} else {
			return false;
		}

	}

	protected boolean createAndAddShortcut(ShortcutInfo item, int toChild) {
		final TextView textView = (TextView) mInflater.inflate(
				R.layout.application, this, false);
		textView.setCompoundDrawablesWithIntrinsicBounds(null,
				new FastBitmapDrawable(item.getIcon(mIconCache)), null, null);
		textView.setText(item.title);
		textView.setTag(item);

		textView.setOnClickListener(this);
		textView.setOnLongClickListener(this);

		// We need to check here to verify that the given item's location isn't
		// already occupied
		// by another item. If it is, we need to find the next available slot
		// and assign
		// it that position. This is an issue when upgrading from the old
		// Folders implementation
		// which could contain an unlimited number of items.
		CellLayout cl = (CellLayout) (mContent.getChildAt(toChild));
		if (cl.getChildAt(item.cellX, item.cellY) != null || item.cellX < 0
				|| item.cellY < 0 || item.cellX >= cl.getCountX()
				|| item.cellY >= cl.getCountY()) {
			if (!findAndSetEmptyCells(item, item.screen)) {
				return false;
			}
		}
		
		CellLayout.LayoutParams lp = new CellLayout.LayoutParams(item.cellX,
				item.cellY, item.spanX, item.spanY);
		boolean insert = false;
		textView.setOnKeyListener(new FolderKeyEventListener());
		cl.addViewToCellLayout(textView, insert ? 0 : -1, (int) item.id, lp,
				true);
		mContent.requestLayout();
		mContent.invalidate();
		return true;
	}
	// }Added by lijuan.li end

	public void onDragEnter(DragObject d) {
		mPreviousTargetCell[0] = -1;
		mPreviousTargetCell[1] = -1;
		mOnExitAlarm.cancelAlarm();
	}

	OnAlarmListener mReorderAlarmListener = new OnAlarmListener() {
		public void onAlarm(Alarm alarm) {
			// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
			// realTimeReorder(mEmptyCell, mTargetCell);
			// }Modified by lijuan.li end
		}
	};

	boolean readingOrderGreaterThan(int[] v1, int[] v2) {
		if (v1[1] > v2[1] || (v1[1] == v2[1] && v1[0] > v2[0])) {
			return true;
		} else {
			return false;
		}
	}

	private void realTimeReorder(int[] empty, int[] target) {
		boolean wrap;
		int startX;
		int endX;
		int startY;
		int delay = 0;
		float delayAmount = 30;
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
		CellLayout cl = (CellLayout) (mContent.getChildAt(mContent
				.getCurrentScreen()));
		if (readingOrderGreaterThan(target, empty)) {
			// wrap = empty[0] >= mContent.getCountX() - 1;
			wrap = empty[0] >= cl.getCountX() - 1;
			startY = wrap ? empty[1] + 1 : empty[1];
			for (int y = startY; y <= target[1]; y++) {
				startX = y == empty[1] ? empty[0] + 1 : 0;
				/*
				 * endX = y < target[1] ? mContent.getCountX() - 1 : target[0];
				 * for (int x = startX; x <= endX; x++) { View v =
				 * mContent.getChildAt(x,y); if
				 * (mContent.animateChildToPosition(v, empty[0], empty[1],
				 */
				endX = y < target[1] ? cl.getCountX() - 1 : target[0];
				for (int x = startX; x <= endX; x++) {
					View v = cl.getChildAt(x, y);
					if (cl.animateChildToPosition(v, empty[0], empty[1],
					// }Modified by lijuan.li
							REORDER_ANIMATION_DURATION, delay)) {
						empty[0] = x;
						empty[1] = y;
						delay += delayAmount;
						delayAmount *= 0.9;
					}
				}
			}
		} else {
			wrap = empty[0] == 0;
			startY = wrap ? empty[1] - 1 : empty[1];
			for (int y = startY; y >= target[1]; y--) {
				// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
				/*
				 * startX = y == empty[1] ? empty[0] - 1 : mContent.getCountX()
				 * - 1; endX = y > target[1] ? 0 : target[0]; for (int x =
				 * startX; x >= endX; x--) { View v = mContent.getChildAt(x,y);
				 * if (mContent.animateChildToPosition(v, empty[0], empty[1],
				 */
				startX = y == empty[1] ? empty[0] - 1 : cl.getCountX() - 1;
				endX = y > target[1] ? 0 : target[0];
				for (int x = startX; x >= endX; x--) {
					View v = cl.getChildAt(x, y);
					if (cl.animateChildToPosition(v, empty[0], empty[1],
					// }Modified by lijuan.li end
							REORDER_ANIMATION_DURATION, delay)) {
						empty[0] = x;
						empty[1] = y;
						delay += delayAmount;
						delayAmount *= 0.9;
					}
				}
			}
		}
	}

	public void onDragOver(DragObject d) {
		float[] r = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
				d.dragView, null);
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
		// mTargetCell = mContent.findNearestArea((int) r[0], (int) r[1], 1, 1,
		// mTargetCell);
		CellLayout cl = (CellLayout) (mContent.getChildAt(mContent
				.getCurrentScreen()));
		mTargetCell = cl.findNearestArea((int) r[0], (int) r[1], 1, 1,
				mTargetCell);
		// }Modified by lijuan.li end

		if (mTargetCell[0] != mPreviousTargetCell[0]
				|| mTargetCell[1] != mPreviousTargetCell[1]) {
			mReorderAlarm.cancelAlarm();
			mReorderAlarm.setOnAlarmListener(mReorderAlarmListener);
			mReorderAlarm.setAlarm(150);
			mPreviousTargetCell[0] = mTargetCell[0];
			mPreviousTargetCell[1] = mTargetCell[1];
		}
	}

	// This is used to compute the visual center of the dragView. The idea is
	// that
	// the visual center represents the user's interpretation of where the item
	// is, and hence
	// is the appropriate point to use when determining drop location.
	private float[] getDragViewVisualCenter(int x, int y, int xOffset,
			int yOffset, DragView dragView, float[] recycle) {
		float res[];
		if (recycle == null) {
			res = new float[2];
		} else {
			res = recycle;
		}

		// These represent the visual top and left of drag view if a dragRect
		// was provided.
		// If a dragRect was not provided, then they correspond to the actual
		// view left and
		// top, as the dragRect is in that case taken to be the entire dragView.
		// R.dimen.dragViewOffsetY.
		int left = x - xOffset;
		int top = y - yOffset;

		// In order to find the visual center, we shift by half the dragRect
		res[0] = left + dragView.getDragRegion().width() / 2;
		res[1] = top + dragView.getDragRegion().height() / 2;

		return res;
	}

	OnAlarmListener mOnExitAlarmListener = new OnAlarmListener() {
		public void onAlarm(Alarm alarm) {
			completeDragExit();
		}
	};

	public void completeDragExit() {
		mLauncher.closeFolder();
		mCurrentDragInfo = null;
		mCurrentDragView = null;
		mSuppressOnAdd = false;
		mRearrangeOnClose = true;
	}

	public void onDragExit(DragObject d) {
		// We only close the folder if this is a true drag exit, ie. not because
		// a drop
		// has occurred above the folder.
		if (!d.dragComplete) {
			mOnExitAlarm.setOnAlarmListener(mOnExitAlarmListener);
			mOnExitAlarm.setAlarm(ON_EXIT_CLOSE_DELAY);
		}
		mReorderAlarm.cancelAlarm();
	}

	public void onDropCompleted(View target, DragObject d, boolean success) {
		if (success) {
			if (mDeleteFolderOnDropCompleted && !mItemAddedBackToSelfViaIcon) {
				replaceFolderWithFinalItem();
			}
		} else {
			// The drag failed, we need to return the item to the folder
			mFolderIcon.onDrop(d);

			// We're going to trigger a "closeFolder" which may occur before
			// this item has
			// been added back to the folder -- this could cause the folder to
			// be deleted
			if (mOnExitAlarm.alarmPending()) {
				mSuppressFolderDeletion = true;
			}
		}

		if (target != this) {
			if (mOnExitAlarm.alarmPending()) {
				mOnExitAlarm.cancelAlarm();
				completeDragExit();
			}
		}
		mDeleteFolderOnDropCompleted = false;
		mDragInProgress = false;
		mItemAddedBackToSelfViaIcon = false;
		mCurrentDragInfo = null;
		mCurrentDragView = null;
		mSuppressOnAdd = false;

		// Reordering may have occured, and we need to save the new item
		// locations. We do this once
		// at the end to prevent unnecessary database operations.
		updateItemLocationsInDatabase();
	}

	private void updateItemLocationsInDatabase() {
		ArrayList<View> list = getItemsInReadingOrder(mContent
				.getCurrentScreen() - 1);
		for (int i = 0; i < list.size(); i++) {
			View v = list.get(i);
			ItemInfo info = (ItemInfo) v.getTag();
			LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, 0,
					info.cellX, info.cellY);
		}
	}

	public void notifyDrop() {
		if (mDragInProgress) {
			mItemAddedBackToSelfViaIcon = true;
		}
	}

	public boolean isDropEnabled() {
		return true;
	}

	public DropTarget getDropTargetDelegate(DragObject d) {
		return null;
	}
	
	private void setupContentDimensions(int count) {
		// }Deleted by lijuan.li at 2012.07.30 for folder with multipage
//		ArrayList<View> list = getItemsInReadingOrder();
//
//		int countX = mContent.getCountX();
//		int countY = mContent.getCountY();
//		boolean done = false;
//
//		while (!done) {
//			int oldCountX = countX;
//			int oldCountY = countY;
//			if (countX * countY < count) {
//				// Current grid is too small, expand it
//				if ((countX <= countY || countY == mMaxCountY)
//						&& countX < mMaxCountX) {
//					countX++;
//				} else if (countY < mMaxCountY) {
//					countY++;
//				}
//				if (countY == 0)
//					countY++;
//			} else if ((countY - 1) * countX >= count && countY >= countX) {
//				countY = Math.max(0, countY - 1);
//			} else if ((countX - 1) * countY >= count) {
//				countX = Math.max(0, countX - 1);
//			}
//			done = countX == oldCountX && countY == oldCountY;
//		}
//
//		mContent.setGridSize(countX, countY);
//		arrangeChildren(list);
		// }Deleted by lijuan.li end
	}

	// {Added by lijuan.li 2012.07.30 begin for folder with multipage
	private void setupContentDimensions(int count, int atChild) {
		CellLayout cl;
		cl = (CellLayout) (mContent.getChildAt(atChild));

		ArrayList<View> list = getItemsInReadingOrder(atChild);

		if (mPageCount == 1) {
			int countX = cl.getCountX();
			int countY = cl.getCountY();

			boolean done = false;

			while (!done) {
				int oldCountX = countX;
				int oldCountY = countY;
				if (countX * countY < count) {
					// Current grid is too small, expand it
					if ((countX <= countY || countY == mMaxCountY) && countX < mMaxCountX) {
						countX++;
					} else if (countY < mMaxCountY) {
						countY++;
					}
					if (countY == 0)
						countY++;
				} else if ((countY - 1) * countX >= count && countY >= countX) {
					countY = Math.max(0, countY - 1);
				} else if ((countX - 1) * countY >= count) {
					countX = Math.max(0, countX - 1);
				}
				done = countX == oldCountX && countY == oldCountY;
			}

			cl.setGridSize(countX, countY);
			mContent.requestLayout();
		}
		arrangeChildren(list, atChild);
	}

	// }Added by lijuan.li end

	public boolean isFull() { return getItemCount() >= mMaxNumItems; }

	private void centerAboutIcon() {
		DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
		/*
		 * int width = getPaddingLeft() + getPaddingRight() +
		 * mContent.getDesiredWidth(); int height = getPaddingTop() +
		 * getPaddingBottom() + mContent.getDesiredHeight() + mFolderNameHeight;
		 */
		CellLayout cl = (CellLayout) (mContent.getChildAt(0));

		int width = getPaddingLeft() + getPaddingRight() + cl.getDesiredWidth();
		int height = getPaddingTop() + getPaddingBottom()
				+ cl.getDesiredHeight() + mFolderNameHeight;
		// Modified by lijuan.li end
		DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);

		parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);

		int centerX = mTempRect.centerX();
		int centerY = mTempRect.centerY();
		int centeredLeft = centerX - width / 2;
		int centeredTop = centerY - height / 2;

		// We first fetch the currently visible CellLayoutChildren
		CellLayout currentPage = mLauncher.getWorkspace()
				.getCurrentDropLayout();
		CellLayoutChildren boundingLayout = currentPage.getChildrenLayout();
		Rect bounds = new Rect();
		parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);

		// We need to bound the folder to the currently visible
		// CellLayoutChildren
		int left = Math.min(Math.max(bounds.left, centeredLeft), bounds.left
				+ bounds.width() - width);
		int top = Math.min(Math.max(bounds.top, centeredTop), bounds.top
				+ bounds.height() - height);
		// If the folder doesn't fit within the bounds, center it about the
		// desired bounds
		if (width >= bounds.width()) {
			left = bounds.left + (bounds.width() - width) / 2;
		}
		if (height >= bounds.height()) {
			top = bounds.top + (bounds.height() - height) / 2;
		}

		int folderPivotX = left / 2 + (centeredLeft - left);
		int folderPivotY = top / 2 + (centeredTop - top);
		setPivotX(folderPivotX);
		setPivotY(folderPivotY);
		int folderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() * (1.0f * folderPivotX / width));
		int folderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() * (1.0f * folderPivotY / height));
		mFolderIcon.setPivotX(folderIconPivotX);
		mFolderIcon.setPivotY(folderIconPivotY);

		if (mMode == PARTIAL_GROW) {
			lp.width = width;
			lp.height = height;
			lp.x = left;
			lp.y = top;
		} else {
			mNewSize.set(left, top, left + width, top + height);
		}
	}
	
    private void setupContentForNumItems(int count) {
        setupContentDimensions(count);

        DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
        if (lp == null) {
            lp = new DragLayer.LayoutParams(0, 0);
            lp.customPosition = true;
            setLayoutParams(lp);
        }
        centerAboutIcon();
    }

	// {Added by lijuan.li 2012.07.30 begin for folder with multipage
	private void setupContentForNumItems(int count, int atChild) {
		setupContentDimensions(count, atChild);
		DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
		if (lp == null) {
			lp = new DragLayer.LayoutParams(0, 0);
			lp.customPosition = true;
			setLayoutParams(lp);
		}
		centerAboutIcon();
	}
	// }Added by lijuan.li end

	protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
		/*
		 * int width = getPaddingLeft() + getPaddingRight() +
		 * mContent.getDesiredWidth(); int height = getPaddingTop() +
		 * getPaddingBottom() + mContent.getDesiredHeight() + mFolderNameHeight;
		 * 
		 * int contentWidthSpec =
		 * MeasureSpec.makeMeasureSpec(mContent.getDesiredWidth(),
		 * MeasureSpec.EXACTLY); int contentHeightSpec =
		 * MeasureSpec.makeMeasureSpec(mContent.getDesiredHeight(),
		 * MeasureSpec.EXACTLY);
		 */
		CellLayout cl = (CellLayout) (mContent.getChildAt(0));
		int width = getPaddingLeft() + getPaddingRight() + cl.getDesiredWidth();
		int height = getPaddingTop() + getPaddingBottom()
				+ cl.getDesiredHeight() + mFolderNameHeight;

		int contentWidthSpec = MeasureSpec.makeMeasureSpec(
				cl.getDesiredWidth(), MeasureSpec.EXACTLY);
		int contentHeightSpec = MeasureSpec.makeMeasureSpec(
				cl.getDesiredHeight(), MeasureSpec.EXACTLY);

		mContent.measure(contentWidthSpec, contentHeightSpec);

		mFolderName.measure(contentWidthSpec, MeasureSpec.makeMeasureSpec(
				mFolderNameHeight, MeasureSpec.EXACTLY));
		setMeasuredDimension(width, height);
		// }Modified by lijuan.li end
	}

	// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
	/*
	 * private void arrangeChildren(ArrayList<View> list) { int[] vacant = new
	 * int[2]; if (list == null) { list = getItemsInReadingOrder(); }
	 * mContent.removeAllViews();
	 * 
	 * for (int i = 0; i < list.size(); i++) { View v = list.get(i);
	 * mContent.getVacantCell(vacant, 1, 1); CellLayout.LayoutParams lp =
	 * (CellLayout.LayoutParams) v.getLayoutParams(); lp.cellX = vacant[0];
	 * lp.cellY = vacant[1]; ItemInfo info = (ItemInfo) v.getTag(); if
	 * (info.cellX != vacant[0] || info.cellY != vacant[1]) { info.cellX =
	 * vacant[0]; info.cellY = vacant[1];
	 * LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id, 0,
	 * info.cellX, info.cellY); } boolean insert = false;
	 * mContent.addViewToCellLayout(v, insert ? 0 : -1, (int)info.id, lp, true);
	 * } mItemsInvalidated = true; }
	 */
	private void arrangeChildren(ArrayList<View> list, int atChild) {
		int[] vacant = new int[2];
		if (list == null) {
			list = getItemsInReadingOrder(atChild);
		}
		CellLayout cl = (CellLayout) (mContent.getChildAt(atChild));

		cl.removeAllViews();

		for (int i = 0; i < mMaxNumItems && i < list.size(); i++) {
			View v = list.get(i);
			cl.getVacantCell(vacant, 1, 1);
			CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v
					.getLayoutParams();
			lp.cellX = vacant[0];
			lp.cellY = vacant[1];
			ItemInfo info = (ItemInfo) v.getTag();

			info.cellX = vacant[0];
			info.cellY = vacant[1];
			LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id,
					info.screen, info.cellX, info.cellY);
			boolean insert = false;
			cl.addViewToCellLayout(v, insert ? 0 : -1, (int) info.id, lp, true);
		}

		mContent.invalidate();
		mItemsInvalidated = true;
	}
	// Modified by lijuan.li end
	
	public int getItemCount() {
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
		// return mContent.getChildrenLayout().getChildCount();
		return 1;
		// }Modified by lijuan.li end
	}
	
	// {Added by lijuan.li 2012.07.30 begin for folder with multipage
	public int getItemCount(int atChild) {
		CellLayout cl = (CellLayout) (mContent.getChildAt(atChild));
		return cl.getChildrenLayout().getChildCount();
	}
	// }Added by lijuan.li end

	public View getItemAt(int index) {
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage
		// return mContent.getChildrenLayout().getChildAt(index);
		CellLayout cl = (CellLayout) (mContent.getChildAt(mContent
				.getCurrentScreen()));
		return cl.getChildrenLayout().getChildAt(index);
		// }Modified by lijuan.li end
	}

	private void onCloseComplete() {
		DragLayer parent = (DragLayer) getParent();
		parent.removeView(this);
		mDragController.removeDropTarget((DropTarget) this);
		clearFocus();
		mFolderIcon.requestFocus();
		// {Modified by lijuan.li 2012.07.30 begin for folder with multipage

		/*
		 * if (mRearrangeOnClose) { setupContentForNumItems(getItemCount());
		 * mRearrangeOnClose = false; } if (getItemCount() <= 1) {
		 */
		int oldPageCount = mPageCount;
		mPageCount = (mInfo.contents.size() - 1) / mMaxNumItems + 1;

		if (mContent.getCurrentScreen() + 1 > mPageCount) {
			mContent.setCurrentScreen(0);
		}

		if (mRearrangeOnClose) {
			ArrayList<ShortcutInfo> children = getAllPageItemsInReadingOrder(oldPageCount);
			mContent.removeAllViewsInLayout();

			if (mPageCount > 1) {
				for (int j = 0; j < mPageCount; j++) {
					CellLayout cl = (CellLayout) LayoutInflater.from(
							getContext()).inflate(R.layout.folder_layout, this,
							false);
					cl.setGridSize(mMaxCountX, mMaxCountY);
					mContent.addView(cl);
				}
			} else {
				CellLayout cl = (CellLayout) LayoutInflater.from(getContext())
						.inflate(R.layout.folder_layout, this, false);
				cl.setGridSize(0, 0);
				mContent.addView(cl);
			}

			int childIndex = 0;
			int miniCount;
			for (int pageIndex = 0; pageIndex < mPageCount; pageIndex++) {
				miniCount = Math.min(children.size(), (pageIndex + 1) * mMaxNumItems);
				for (; childIndex < miniCount; childIndex++) {
					ShortcutInfo child = (ShortcutInfo) children.get(childIndex);
					child.screen = pageIndex;
					if (mPageCount == 1) {
						if (!findAndSetEmptyCells(child, pageIndex)) {
							// The current layout is full, can we expand it?
							mItemsInvalidated = true;
							setupContentForNumItems(getItemCount(pageIndex) + 1, pageIndex);
							findAndSetEmptyCells(child, pageIndex);
						}
					} else {
						findAndSetEmptyCells(child, pageIndex);
					}
					createAndAddShortcut(child, child.screen);
					LauncherModel.addOrMoveItemInDatabase(mLauncher, child,
							mInfo.id, child.screen, child.cellX, child.cellY);
				}
			}
			mContent.requestLayout();
			mContent.invalidate();
			mRearrangeOnClose = false;
		}
		if (getItemCount(0) <= 1 && mContent.getChildCount() == 1) {
			// }Modified by lijuan.li end
			if (!mDragInProgress && !mSuppressFolderDeletion) {
				replaceFolderWithFinalItem();
			} else if (mDragInProgress) {
				mDeleteFolderOnDropCompleted = true;
			}
		}
		mSuppressFolderDeletion = false;
	}

	private void replaceFolderWithFinalItem() {
		ItemInfo finalItem = null;

		// }Modified by lijuan.li 2012.07.11 begin for folder with multipage
		// if (getItemCount() == 1) {
		if (getItemCount(mContent.getCurrentScreen()) == 1) {
			// }Modified by lijuan.li end
			finalItem = mInfo.contents.get(0);
		}

		// Remove the folder completely
		CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container,
				mInfo.screen);
		cellLayout.removeView(mFolderIcon);
		if (mFolderIcon instanceof DropTarget) {
			mDragController.removeDropTarget((DropTarget) mFolderIcon);
		}
		mLauncher.removeFolder(mInfo);

		if (finalItem != null) {
			LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem,
					mInfo.container, mInfo.screen, mInfo.cellX, mInfo.cellY);
		}
		LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);

		// Add the last remaining child to the workspace in place of the folder
		if (finalItem != null) {
			View child = mLauncher.createShortcut(R.layout.application,
					cellLayout, (ShortcutInfo) finalItem);

			mLauncher.getWorkspace().addInScreen(child, mInfo.container,
					mInfo.screen, mInfo.cellX, mInfo.cellY, mInfo.spanX,
					mInfo.spanY);
		}
	}

	// This method keeps track of the last item in the folder for the purposes
	// of keyboard focus
	private void updateTextViewFocus() {
		// }Modified by lijuan.li 2012.07.11 begin for folder with multipage
		// View lastChild = getItemAt(getItemCount() - 1);
		// getItemAt(getItemCount() - 1);
		View lastChild = getItemAt(getItemCount(mContent.getCurrentScreen()));
		getItemAt(getItemCount(mContent.getCurrentScreen()));
		// Modified by lijuan.li end
		if (lastChild != null) {
			mFolderName.setNextFocusDownId(lastChild.getId());
			mFolderName.setNextFocusRightId(lastChild.getId());
			mFolderName.setNextFocusLeftId(lastChild.getId());
			mFolderName.setNextFocusUpId(lastChild.getId());
		}
	}

	public void onDrop(DragObject d) {
		ShortcutInfo item;
		if (d.dragInfo instanceof ApplicationInfo) {
			// Came from all apps -- make a copy
			item = ((ApplicationInfo) d.dragInfo).makeShortcut();
			item.spanX = 1;
			item.spanY = 1;
		} else {
			item = (ShortcutInfo) d.dragInfo;
		}
		// Dragged from self onto self, currently this is the only path
		// possible, however
		// we keep this as a distinct code path.
		if (item == mCurrentDragInfo) {
			ShortcutInfo si = (ShortcutInfo) mCurrentDragView.getTag();
			CellLayout.LayoutParams lp = (CellLayout.LayoutParams) mCurrentDragView
					.getLayoutParams();
			si.cellX = lp.cellX = mEmptyCell[0];
			si.cellX = lp.cellY = mEmptyCell[1];
			// }Modified by lijuan.li 2012.07.11 begin for folder with multipage
			// mContent.addViewToCellLayout(mCurrentDragView, -1, (int)item.id,
			// lp, true);
			CellLayout cl = (CellLayout) (mContent.getChildAt(mContent
					.getCurrentScreen()));
			item.screen = mContent.getCurrentScreen();
			cl.addViewToCellLayout(mCurrentDragView, -1, (int) item.id, lp,
					true);
			// Modified by lijuan.li end
			if (d.dragView.hasDrawn()) {
				mLauncher.getDragLayer().animateViewIntoPosition(d.dragView,
						mCurrentDragView);
			} else {
				mCurrentDragView.setVisibility(VISIBLE);
			}
			mItemsInvalidated = true;

			// Modefied by lijuan.li 2012.07.11 begin for folder with multipage
			// setupContentDimensions(getItemCount());
			setupContentDimensions(getItemCount(mContent.getCurrentScreen()),
					mContent.getCurrentScreen());
			// Modified by lijuan.li end
			mSuppressOnAdd = true;
		}
		mInfo.add(item);
	}

	public void onAdd(ShortcutInfo item) {
		mItemsInvalidated = true;
		// If the item was dropped onto this open folder, we have done the work
		// associated
		// with adding the item to the folder, as indicated by mSuppressOnAdd
		// being set
		if (mSuppressOnAdd)
			return;
		// }Modified by lijuan.li 2012.07.11 begin for folder with multipage
		/*
		 * if (!findAndSetEmptyCells(item)) { // The current layout is full, can
		 * we expand it? setupContentForNumItems(getItemCount() + 1);
		 * findAndSetEmptyCells(item); } createAndAddShortcut(item);
		 * LauncherModel.addOrMoveItemInDatabase( mLauncher, item, mInfo.id, 0,
		 * item.cellX, item.cellY);
		 */
		mPageCount = (mInfo.contents.size() - 1) / mMaxNumItems + 1;

		if (mContent.getChildCount() < mPageCount) {
			CellLayout cl = (CellLayout) LayoutInflater.from(getContext())
					.inflate(R.layout.folder_layout, this, false);
			cl.setGridSize(mMaxCountX, mMaxCountY);
			mContent.addView(cl);
		}

		if (item.cellX == -1 || item.cellY == -1) {
			item.screen = mPageCount - 1;
			if (mPageCount == 1) {
				if (!findAndSetEmptyCells(item, mPageCount - 1)) {
					// The current layout is full, can we expand it?
					setupContentForNumItems(getItemCount(mPageCount - 1) + 1,
							mPageCount - 1);
					findAndSetEmptyCells(item, mPageCount - 1);
				}
			} else {
				findAndSetEmptyCells(item, mPageCount - 1);
			}
		} else if (mPageCount == 1){
			setupContentForNumItems(getItemCount(item.screen) + 1, item.screen);
		}

		createAndAddShortcut(item, item.screen);
		mContent.requestLayout();
		mContent.invalidate();
		// }Modified by lijuan.li end
		LauncherModel.addOrMoveItemInDatabase(mLauncher, item, mInfo.id,
				item.screen, item.cellX, item.cellY);
	}

	public void onRemove(ShortcutInfo item) {
		mItemsInvalidated = true;
		// If this item is being dragged from this open folder, we have already
		// handled
		// the work associated with removing the item, so we don't have to do
		// anything here.
		if (item == mCurrentDragInfo)
			return;
		// }Modified by lijuan.li 2012.07.11 begin for folder with multipage
		/*
		 * View v = getViewForInfo(item); mContent.removeView(v); if (mState ==
		 * STATE_ANIMATING) { mRearrangeOnClose = true; } else {
		 * setupContentForNumItems(getItemCount()); } if (getItemCount() <= 1) {
		 * replaceFolderWithFinalItem();
		 */
		mContent.removeAllViews();
		ArrayList<ShortcutInfo> children = mInfo.contents;
		children.remove(item);
		mPageCount = children.size() / mMaxNumItems + 1;

		if (mState == STATE_ANIMATING) {
			mRearrangeOnClose = true;
		} else if (children.size() <= 1 && mPageCount == 1) {
			replaceFolderWithFinalItem();
		}
	}

    private View getViewForInfo(ShortcutInfo item) {
		// {Deleted by lijuan.li 2012.07.30 begin for folder with multipage
//		for (int j = 0; j < mContent.getCountY(); j++) {
//			for (int i = 0; i < mContent.getCountX(); i++) {
//				View v = mContent.getChildAt(i, j);
//				if (v.getTag() == item) {
//					return v;
//				}
//			}
//		}
		// } Deleted by lijuan.li end
		return null;
    }

	public void onItemsChanged() {
		updateTextViewFocus();
	}

	public void onTitleChanged(CharSequence title) {
	}
	
    public ArrayList<View> getItemsInReadingOrder() {
        return getItemsInReadingOrder(true);
    }

    public ArrayList<View> getItemsInReadingOrder(boolean includeCurrentDragItem) {
        //{Deleted by lijuan.li 2012.07.30 begin for folder with multipage
//        if (mItemsInvalidated) {
//            mItemsInReadingOrder.clear();
//            for (int j = 0; j < mContent.getCountY(); j++) {
//                for (int i = 0; i < mContent.getCountX(); i++) {
//                    View v = mContent.getChildAt(i, j);
//                    if (v != null) {
//                        ShortcutInfo info = (ShortcutInfo) v.getTag();
//                        if (info != mCurrentDragInfo || includeCurrentDragItem) {
//                            mItemsInReadingOrder.add(v);
//                        }
//                    }
//                }
//            }
//            mItemsInvalidated = false;
//        }
        //}Deleted by lijuan.li end
        return mItemsInReadingOrder;
    }
	//{Added by lijuan.li for folder with multipage
	public ArrayList<View> getItemsInReadingOrder(int atChild) {
		return getItemsInReadingOrder(true, atChild);
	}

	public ArrayList<View> getItemsInReadingOrder(
			boolean includeCurrentDragItem, int atChild) {
		if (mItemsInvalidated) {
			mItemsInReadingOrder.clear();
			CellLayout cl = (CellLayout) mContent.getChildAt(atChild);
			if (cl == null)
				return mItemsInReadingOrder;
			int countX = 0;
			for (int countY = 0; countY < cl.getCountY(); countY++) {
				for (countX = 0; countX < cl.getCountX(); countX++) {
					View v = cl.getChildAt(countX, countY);
					if (v != null) {
						ShortcutInfo info = (ShortcutInfo) v.getTag();
						if (info != mCurrentDragInfo || includeCurrentDragItem) {
							mItemsInReadingOrder.add(v);
						}
					}
				}
			}
			mItemsInvalidated = false;
		}
		return mItemsInReadingOrder;
	}
	
	public ArrayList<ShortcutInfo> getAllPageItemsInReadingOrder(
			int oldPageCount) {
		mItemsAllPageInReadingOrder.clear();
		CellLayout cl;
		int countX = 0;
		for (int pageCount = 0; pageCount < oldPageCount; pageCount++) {
			cl = (CellLayout) (mContent.getChildAt(pageCount));
			for (int countY = 0; countY < cl.getCountY(); countY++) {
				for (countX = 0; countX < cl.getCountX(); countX++) {
					View v = cl.getChildAt(countX, countY);
					if (v != null) {
						ShortcutInfo info = (ShortcutInfo) v.getTag();
						mItemsAllPageInReadingOrder.add(info);
					}
				}
			}
		}
		return mItemsAllPageInReadingOrder;
	}
	// {Added by lijuan.li end
	
	public ArrayList<View> getItemsInReadingOrderWithInvalidate(
			boolean includeCurrentDragItem) {
		if (mItemsInvalidated) {
			mItemsInReadingOrder.clear();
			Log.e("lljhome", "current screen" + mContent.getCurrentScreen());
			CellLayout cl = (CellLayout) (mContent.getChildAt(0));
			if (cl == null)
				return mItemsInReadingOrder;
			int countX = 0;
			for (int countY = 0; countY < cl.getCountY(); countY++) {
				for (countX = 0; countX < cl.getCountX(); countX++) {
					View v = cl.getChildAt(countX, countY);
					if (v != null) {
						ShortcutInfo info = (ShortcutInfo) v.getTag();
						if (info != mCurrentDragInfo || includeCurrentDragItem) {
							mItemsInReadingOrder.add(v);
						}
					}
				}
			}
			mItemsInvalidated = false;
		}

		if (mInfo.contents.size() >= mMaxNumItems && mItemsInReadingOrder.size() == mMaxNumItems - 1) {
			CellLayout cl = (CellLayout) (mContent.getChildAt(1));
			View v = cl.getChildAt(0, 0);
			ShortcutInfo info = (ShortcutInfo) v.getTag();
			if (info != mCurrentDragInfo || includeCurrentDragItem) {
				mItemsInReadingOrder.add(v);
			}
		}

		return mItemsInReadingOrder;
	}

	// }Added by lijuan.li end

	public void getLocationInDragLayer(int[] loc) {
		mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
	}

	public void onFocusChange(View v, boolean hasFocus) {
		if (v == mFolderName && hasFocus) {
			startEditingFolderName();
		}
	}
}
